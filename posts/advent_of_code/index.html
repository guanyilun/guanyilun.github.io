<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Advent of Code | Yilun Guan</title>
<meta name="keywords" content="">
<meta name="description" content="Day 1 This question is about finding the first and last &ldquo;digit&rdquo; which could be written as number or word and computing the sum over all input lines. My attempt with julia:
digits_lookup = Dict( &#34;0&#34; =&gt; 0, &#34;1&#34; =&gt; 1, &#34;2&#34; =&gt; 2, &#34;3&#34; =&gt; 3, &#34;4&#34; =&gt; 4, &#34;5&#34; =&gt; 5, &#34;6&#34; =&gt; 6, &#34;7&#34; =&gt; 7, &#34;8&#34; =&gt; 8, &#34;9&#34; =&gt; 9, &#34;zero&#34; =&gt; 0, &#34;one&#34; =&gt; 1, &#34;two&#34; =&gt; 2, &#34;three&#34; =&gt; 3, &#34;four&#34; =&gt; 4, &#34;five&#34; =&gt; 5, &#34;six&#34; =&gt; 6, &#34;seven&#34; =&gt; 7, &#34;eight&#34; =&gt; 8, &#34;nine&#34; =&gt; 9 ) function parse_number(line) out, digit = 0, 0 for i in eachindex(line) for (k, v) in digits_lookup if line[i:min(i&#43;length(k)-1, length(line))] == k digit = v break end end out = out &gt; 0 ?">
<meta name="author" content="Yilun Guan">
<link rel="canonical" href="https://guanyilun.github.io/posts/advent_of_code/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css" integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://guanyilun.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://guanyilun.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://guanyilun.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://guanyilun.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://guanyilun.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>

<script src="https://guanyilun.github.io/js/mathjax-config.js"></script>


<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>

<meta property="og:title" content="Advent of Code" />
<meta property="og:description" content="Day 1 This question is about finding the first and last &ldquo;digit&rdquo; which could be written as number or word and computing the sum over all input lines. My attempt with julia:
digits_lookup = Dict( &#34;0&#34; =&gt; 0, &#34;1&#34; =&gt; 1, &#34;2&#34; =&gt; 2, &#34;3&#34; =&gt; 3, &#34;4&#34; =&gt; 4, &#34;5&#34; =&gt; 5, &#34;6&#34; =&gt; 6, &#34;7&#34; =&gt; 7, &#34;8&#34; =&gt; 8, &#34;9&#34; =&gt; 9, &#34;zero&#34; =&gt; 0, &#34;one&#34; =&gt; 1, &#34;two&#34; =&gt; 2, &#34;three&#34; =&gt; 3, &#34;four&#34; =&gt; 4, &#34;five&#34; =&gt; 5, &#34;six&#34; =&gt; 6, &#34;seven&#34; =&gt; 7, &#34;eight&#34; =&gt; 8, &#34;nine&#34; =&gt; 9 ) function parse_number(line) out, digit = 0, 0 for i in eachindex(line) for (k, v) in digits_lookup if line[i:min(i&#43;length(k)-1, length(line))] == k digit = v break end end out = out &gt; 0 ?" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://guanyilun.github.io/posts/advent_of_code/" /><meta property="article:section" content="posts" />

<meta property="article:modified_time" content="2023-12-07T17:13:05-05:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Advent of Code"/>
<meta name="twitter:description" content="Day 1 This question is about finding the first and last &ldquo;digit&rdquo; which could be written as number or word and computing the sum over all input lines. My attempt with julia:
digits_lookup = Dict( &#34;0&#34; =&gt; 0, &#34;1&#34; =&gt; 1, &#34;2&#34; =&gt; 2, &#34;3&#34; =&gt; 3, &#34;4&#34; =&gt; 4, &#34;5&#34; =&gt; 5, &#34;6&#34; =&gt; 6, &#34;7&#34; =&gt; 7, &#34;8&#34; =&gt; 8, &#34;9&#34; =&gt; 9, &#34;zero&#34; =&gt; 0, &#34;one&#34; =&gt; 1, &#34;two&#34; =&gt; 2, &#34;three&#34; =&gt; 3, &#34;four&#34; =&gt; 4, &#34;five&#34; =&gt; 5, &#34;six&#34; =&gt; 6, &#34;seven&#34; =&gt; 7, &#34;eight&#34; =&gt; 8, &#34;nine&#34; =&gt; 9 ) function parse_number(line) out, digit = 0, 0 for i in eachindex(line) for (k, v) in digits_lookup if line[i:min(i&#43;length(k)-1, length(line))] == k digit = v break end end out = out &gt; 0 ?"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Posts",
      "item": "https://guanyilun.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "Advent of Code",
      "item": "https://guanyilun.github.io/posts/advent_of_code/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Advent of Code",
  "name": "Advent of Code",
  "description": "Day 1 This question is about finding the first and last \u0026ldquo;digit\u0026rdquo; which could be written as number or word and computing the sum over all input lines. My attempt with julia:\ndigits_lookup = Dict( \u0026#34;0\u0026#34; =\u0026gt; 0, \u0026#34;1\u0026#34; =\u0026gt; 1, \u0026#34;2\u0026#34; =\u0026gt; 2, \u0026#34;3\u0026#34; =\u0026gt; 3, \u0026#34;4\u0026#34; =\u0026gt; 4, \u0026#34;5\u0026#34; =\u0026gt; 5, \u0026#34;6\u0026#34; =\u0026gt; 6, \u0026#34;7\u0026#34; =\u0026gt; 7, \u0026#34;8\u0026#34; =\u0026gt; 8, \u0026#34;9\u0026#34; =\u0026gt; 9, \u0026#34;zero\u0026#34; =\u0026gt; 0, \u0026#34;one\u0026#34; =\u0026gt; 1, \u0026#34;two\u0026#34; =\u0026gt; 2, \u0026#34;three\u0026#34; =\u0026gt; 3, \u0026#34;four\u0026#34; =\u0026gt; 4, \u0026#34;five\u0026#34; =\u0026gt; 5, \u0026#34;six\u0026#34; =\u0026gt; 6, \u0026#34;seven\u0026#34; =\u0026gt; 7, \u0026#34;eight\u0026#34; =\u0026gt; 8, \u0026#34;nine\u0026#34; =\u0026gt; 9 ) function parse_number(line) out, digit = 0, 0 for i in eachindex(line) for (k, v) in digits_lookup if line[i:min(i+length(k)-1, length(line))] == k digit = v break end end out = out \u0026gt; 0 ?",
  "keywords": [
    
  ],
  "articleBody": "Day 1 This question is about finding the first and last “digit” which could be written as number or word and computing the sum over all input lines. My attempt with julia:\ndigits_lookup = Dict( \"0\" =\u003e 0, \"1\" =\u003e 1, \"2\" =\u003e 2, \"3\" =\u003e 3, \"4\" =\u003e 4, \"5\" =\u003e 5, \"6\" =\u003e 6, \"7\" =\u003e 7, \"8\" =\u003e 8, \"9\" =\u003e 9, \"zero\" =\u003e 0, \"one\" =\u003e 1, \"two\" =\u003e 2, \"three\" =\u003e 3, \"four\" =\u003e 4, \"five\" =\u003e 5, \"six\" =\u003e 6, \"seven\" =\u003e 7, \"eight\" =\u003e 8, \"nine\" =\u003e 9 ) function parse_number(line) out, digit = 0, 0 for i in eachindex(line) for (k, v) in digits_lookup if line[i:min(i+length(k)-1, length(line))] == k digit = v break end end out = out \u003e 0 ? out : digit * 10 end out + digit end lines = readlines(\"input.txt\") parse_number.(lines) |\u003e sum Day 2 This question practices string splitting. I made use of a trick that each occurance of “red”, “blue”, and “green” in a line corresponds to a different draw, so one can easily use one regular expression to find all matches and then find the upper limit to the number of balls.\nPart 1:\nlines = readlines(\"input.txt\") function process_line(line) r, g, b = map(color -\u003e max(map(m -\u003e parse(Int, m.captures[1]), eachmatch(Regex(\"(\\\\d+) $(color)\"), line))...), [\"red\", \"green\", \"blue\"]) (r \u003c= 12 \u0026\u0026 g \u003c= 13 \u0026\u0026 b \u003c= 14) end map(line -\u003e process_line(line[2]) ? line[1] : 0, enumerate(lines)) |\u003e sum Part 2\nfunction process_line(line) r, g, b = map(color -\u003e max(map(m -\u003e parse(Int, m.captures[1]), eachmatch(Regex(\"(\\\\d+) $(color)\"), line))...), [\"red\", \"green\", \"blue\"]) r * g * b end map(process_line, lines) |\u003e sum Day 3 Day 3 problem is about finding numbers that are next to special characters including diagonally, with an input like\n467..114.. ...*...... ..35..633. ......#... 617*...... .....+.58. ..592..... ......755. ...$.*.... .664.598.. The adjacent criteria can be described with\n\"\"\" x = (line_num, [indices...]) y = (line_num, index) \"\"\" function close_by(x, y) (lx, idx), (ly, idy) = x, y (abs(lx - ly) \u003e 1) \u0026\u0026 return false ((idy \u003e maximum(idx) + 1) || (idy \u003c minimum(idx) - 1)) \u0026\u0026 return false return true end where x is a tuple that contains the line number and the string indices of each number, and y is a tuple that similarly contains the line number and an index of the special character (always has length 1).\nNext we can parse the numbers and special characters in the format expected by this function with\nspc = []; num = [] map(x -\u003e map(m-\u003epush!(spc, (x[1], m[1])), findall(r\"[^0-9\\.]\", x[2])), enumerate(lines)) map(x -\u003e map(m-\u003epush!(num, (x[1], collect(m))), findall(r\"(\\d+)\", x[2])), enumerate(lines)) where we have used the regex exclusion syntax [^0-9.] to exclude all dots and numbers to help us find special characters, and have used matched group notation (\\d+) to find all numbers in a line.\nThe question asks us for the sum of all numbers that are adjacent to a special character, it can be simply calculated with\nsum(num |\u003e filter(x -\u003e any(map(y -\u003e close_by(x, y), spc))) .|\u003e x -\u003e parse(Int, lines[x[1]][x[2]])) For part 2, it defines a concept of “gear” which is a “*” character that has exactly two numbers adjacent to it. And, the question asks us to find all gears in an input text and compute the product of two numbers for each gear, and then sum the result for all gears. This can be easily achieved with\nprod = 0 for c in spc if lines[c[1]][c[2]] == '*' nums_close = num |\u003e filter(n-\u003eclose_by(n, c)) (length(nums_close) == 2) \u0026\u0026 (prod += mapreduce(n-\u003eparse(Int, lines[n[1]][n[2]]), *, nums_close)) end end prod or, for people who like one-liner,\n((spc |\u003e filter(x -\u003e lines[x[1]][x[2]] == '*')) .|\u003e c -\u003e ((num |\u003e filter(n-\u003eclose_by(n, c))) |\u003e length) == 2 ? mapreduce(n-\u003eparse(Int, lines[n[1]][n[2]]), *, num |\u003e filter(n-\u003eclose_by(n, c))) : 0) |\u003e sum Day 4 Today’s question is about finding matching numbers on the card,\nCard 1: 41 48 83 86 17 | 83 86 6 31 17 9 48 53 Card 2: 13 32 20 16 61 | 61 30 68 82 17 32 24 19 Card 3: 1 21 53 59 44 | 69 82 63 72 16 21 14 1 Card 4: 41 92 73 84 69 | 59 84 76 51 58 5 54 83 Card 5: 87 83 26 28 32 | 88 30 70 12 93 22 82 36 Card 6: 31 18 13 56 72 | 74 77 10 23 35 67 36 11 For example, in the first card, there are four matching numbers.\nThe first part of the question asks us to compute the score of the card which is calculated as the following: first matching number on a card gives a score of 1, any additional matches doubles the existing score. The question requires us to calculate the total score given an input list of cards.\nOne simple way to find common numbers amount list is through Set interaction:\n\"\"\" expr: string with numbers separated by spaces \"\"\" function parse_int(expr) strip(expr) |\u003e x -\u003e split(x, r\"\\s+\") .|\u003e x -\u003e parse(Int, x) end \"\"\" count the number of winning numbers \"\"\" function get_match_count(line) (split(line, \":\")[2] |\u003e x -\u003e split(x, \"|\") .|\u003e parse_int .|\u003e Set) |\u003e x -\u003e intersect(x...) |\u003e length end # get total score (get_match_count.(lines) .|\u003e x -\u003e x == 0 ? 0 : 2^(x-1)) |\u003e sum where we defined the get_match_count function to find the total number of winning numbers based on the number of elements in the intersection between the two lists. We then use the numbers for each card to calculate the total score based on the description, which is \\(2^{x-1}\\) except when \\(x\\) is 0 which has a zero score.\nFor part two, instead of calculating scores, each card rewards subsequent n cards with n the number of matching numbers in the card. For example, card 1 has 4 matching numbers and will give card 2, 3, 4, 5 as reward, so now there are two copies of card 2 for example. When resolving card 2 award, we repeat the process except we have two copies of card 2 now. It accumulates throughout the card stack, and the question asks us to find the total number of cards at the end of resolving all cards. Here is my solution:\nmultiplier = [ones(length(lines)); zeros(10)] for (i, line) in enumerate(lines) n_match = get_match_count(line) multiplier[i+1:i+n_match] .+= multiplier[i] end sum(multiplier) where I used the multiplier to keep track of the number of card copies. The 10 additional zeros I padded to the multiplier is to ensure the multiplier[i+i:n_match] never goes out of range.\nDay 5 Today’s question tests table mapping. It defines some mapping rules from various quantities such as mapping between seed and soil, mapping between soil to fertilizer, and so on, eventually to location. The rule is given like this\nseeds: 79 14 55 13 seed-to-soil map: 50 98 2 52 50 48 soil-to-fertilizer map: 0 15 37 37 52 2 39 0 15 fertilizer-to-water map: 49 53 8 0 11 42 42 0 7 57 7 4 water-to-light map: 88 18 7 18 25 70 light-to-temperature map: 45 77 23 81 45 19 68 64 13 temperature-to-humidity map: 0 69 1 1 0 69 humidity-to-location map: 60 56 37 56 93 4 For part one, the question asked us to traverse the series of mapping to find the correct location for each input seed and identifies the nearest location which corresponds to then smallest location id.\nFirst we need to work on parsing the input text:\nseeds = match(r\"seeds: (.*)\\n\", text).captures[1] |\u003e split .|\u003e x -\u003e parse(Int, x) parse_arr = cat -\u003e match(Regex(\"$(cat) map:\\\\s*\\\\n((?:\\\\s*\\\\d+\\\\s+\\\\d+\\\\s+\\\\d+\\\\s*\\\\n)+)\"), text).captures[1] |\u003e split |\u003e x -\u003e reshape(x, 3, :) .|\u003e x -\u003e parse.(Int, x) parse_map = cat -\u003e parse_arr(cat) |\u003e x -\u003e map(eachcol(x)) do m ((m[2], m[2]+m[3]-1), (m[1], m[1]+m[3]-1)) end mappings = parse_map.([ \"seed-to-soil\", \"soil-to-fertilizer\", \"fertilizer-to-water\", \"water-to-light\", \"light-to-temperature\", \"temperature-to-humidity\", \"humidity-to-location\" ]) In the input file, the mapping rule is specified as (dest_start, src_start, range); I have converted it to a more readable format: ((src_start, src_stop), (dest_start, dest_stop)) with the parse_map function. The game rule also specifies that any numbers not covered in the specified ranges will passthrough to itself. For completeness, I will also add these dummy ranges: ((0, first), (0, first)) and ((last, inf), (last, inf)). I used inf because I don’t know the largest number in the input text and I don’t want to compute it unnecessarily:\nmappings = map(mappings) do mapping strt = (0, minimum(mapping[i][1][1] for i in eachindex(mapping))) stop = (maximum(mapping[i][1][2] for i in eachindex(mapping)), Inf) strt[2] == 0 ? (mapping..., (stop, stop)) : ((strt, strt), mapping..., (stop, stop)) end To apply a mapping, we simply go through the source ranges to find a match and apply the right offset to the destination range.\nfunction apply_mapping(i, mapping) for m in mapping (m[1][1] \u003c= i \u003c= m[1][2]) \u0026\u0026 return m[2][1] + (i - m[1][1]) end return i end Then we can find the “location” for each “seed” by traversing all mappings via\nfoldl((x, f) -\u003e f.(x), [x -\u003e apply_mapping(x, m) for m in mappings], init=seeds) |\u003e minimum and get the minimum location. This solves the first part.\nIn part 2 of the question, it suggests the input seeds, instead of being individual seeds, are actually pairs of numbers, with the second number specifying a range. The method that we setup in part 1 then becomes very costly because it may require us to repeatedly calculating mapping over up to 1e9 points (as in the input). It’s not prohibitive for a modern computer but unnecessary, because we could simply keep track of how intervals map to each other, i.e., how different intervals in “seeds” space map onto “locations” space. To work out the interval mapping, we first setup some useful functions that deals with intersections of intervals\nhas_intersect = (inter1, inter2) -\u003e sign(inter1[2] - inter2[1]) * sign(inter1[1] - inter2[2]) \u003c= 0 interval_intersect = (inter1, inter2) -\u003e begin !has_intersect(inter1, inter2) \u0026\u0026 return nothing (max(inter1[1], inter2[1]), min(inter1[2], inter2[2])) end To map intervals in input space of map1 to output space of map2, we can use this function\nfunction reduce_mapping(map1, map2) omap = [] for m1 in map1 for m2 in map2 inter = interval_intersect(m1[2], m2[1]) if !isnothing(inter) offset1 = m1[1][1] - m1[2][1] offset2 = -m2[1][1] + m2[2][1] push!(omap, (inter .+ offset1, inter .+ offset2)) end end end omap end For example, given\nmap1 = (((0, 50), (0, 50)), ((98, 99), (50, 51)), ((50, 97), (52, 99)), ((99, Inf), (99, Inf))) map2 = (((15, 51), (0, 36)), ((52, 53), (37, 38)), ((0, 14), (39, 53)), ((53, Inf), (53, Inf))) the reduced mapping is\nreduce_mapping(map1, map2) = (((15, 50), (0, 35)), ((0, 14), (39, 53)), ((98, 99), (35, 36)), ((50, 51), (37, 38)), ((51, 97.0), (53, 99.0)), ((99, Inf), (99, Inf))) We can then apply this reduction through all mappings to work out interval mappings between seed space and location space, by\nomap = foldl((x, y) -\u003e reduce_mapping(x, y), mappings) To find out the nearest location again like in part one, we can find intersections of the input ranges to the intervals specified in the mapping and figure out how these intervals mapped to location space to identify the nearest location. The math is identical to how we compute the combined mapping in reduce_mapping, so we can reuse it with\n# now seeds are pairs of numbers which we will convert to a mapping format imap = seeds |\u003e x -\u003e reshape(x, 2, :) |\u003e x -\u003e map(eachcol(x)) do c ((c[1], c[1] + c[2] - 1), (c[1], c[1] + c[2] - 1)) end reduce_mapping(imap, omap) |\u003e m -\u003e map(x -\u003e x[2][1], m) |\u003e minimum This allows me to easily find the minimum location.\nDay 6 Today’s question very straightforward, about finding number of integers of a quadratic function above a given threshold, so I will just record my solution here:\n# parse data data = map(l -\u003e split(l, r\"\\s+\")[2:end] .|\u003e x -\u003e parse(Int, x), readlines(\"input.txt\")) |\u003e stack # part 1 # data = map(l -\u003e (split(l, r\"\\s+\")[2:end] |\u003e join) |\u003e x -\u003e parse(Int, x), readlines(\"input.txt\")) |\u003e stack # for part 2 map(eachrow(data)) do r t, d = r ceil((t+sqrt(t^2-4d))/2) - floor((t-sqrt(t^2-4d))/2) - 1 end |\u003e prod I did learn a good trick from this exercise, when counting numbers of integers between lower and upper, using floor(upper) - ceil(lower) + 1 is prune to error because it will fail when lower or upper are on integers so I had to add a conditional for this. A robust way to count is to use ceil(upper) - floor(lower) - 1, which I just learned from reddit.\nDay 7 Today’s question is about ranking sets of cards. There are thirteen cards with ranking (descending): A, K, Q, J, T, 9, 8, 7, 6, 5, 4, 3, 2. Each hand has 5 cards, with some combination types ranking (descending):\nFive of a kind, where all five cards have the same label: AAAAA Four of a kind, where four cards have the same label and one card has a different label: AA8AA Full house, where three cards have the same label, and the remaining two cards share a different label: 23332 Three of a kind, where three cards have the same label, and the remaining two cards are each different from any other card in the hand: TTT98 Two pair, where two cards share one label, two other cards share a second label, and the remaining card has a third label: 23432 One pair, where two cards share one label, and the other three cards have a different label from the pair and each other: A23A4 High card, where all cards’ labels are distinct: 23456 When two hands has the same type, it compares individual cards in the order they appear by the card order. The first part asks us to find ranking of cards and compute the total ranking * bidding. Today’s program will be in python. First parsing the file with\nfrom pathlib import Path lines = Path(\"input.txt\").read_text().splitlines() Suppose I have a hand of cards: AKAA2, how do I rank its type? The original method I came up with is to define some patterns based on the number of repeated cards and then find the ranking as its index in the list:\nfrom collections import Counter hand = \"AKAA2\" # an example patterns = [\"11111\", \"1112\", \"122\", \"113\", \"23\", \"14\", \"5\"] card_type = patterns.index(\"\".join(map(str, sorted(Counter(hand).values())))) I read about a neat ranking trick from some reddit users, which I thought will be nice to record here:\ncard_type = max(map(hand.count, hand)) - len(set(hand)) one could check that they have the same ranking effect by comparing the ranking numbers\npattern method 1 method 2 11111 0 -4 1112 1 -2 122 2 -1 113 3 0 23 4 1 14 5 2 5 6 4 To compare hands of the same type, we can make use of the build-in comparison in python that compares list (or tuple) in order, which is exactly what we need (I also learned about it today). For example, this works in Python:\n[10, 2, 2]) \u003e [10, 2, 1] # so are these (3, [10, 2, 2]) \u003e (3, [10, 2, 1]) (3, [10, 2, 1]) \u003e (2, [10, 2, 2]) Therefore we can rank hands simply with\norders = \"23456789TJQKA\" rankings = sorted((max(map(hand.count, hand)) - len(set(hand)), list(map(orders.index, hand)), int(bid)) for line in lines if (hand := line.split()[0]) and (bid := line.split()[1])) then one can easily get ranking * bid as question asks\nsum((i+1) * bid for i, (_, _, bid) in enumerate(rankings)) For part 2, the question introduces some special rule for Joker card that it could be used to represent any card to maximize the hand ranking when considering hand types. One could easily see that to maximize hand ranking, we would always want to replace Joker cards with the most frequently appearing card. To compensate for the increased power of Joker, its individual card ranking has becomes the smallest. So to solve part 2, we simply need to rerun part 1 with a minor correction that\nhand = hand.replace(\"J\", Counter(\"J\").most_common()[0][0]) orders = \"J23456789TQKA\" so I will not repeat. I liked today’s puzzle because it taught me a few tricks in python such as structured comparisons, and inline assignments.\n",
  "wordCount" : "2691",
  "inLanguage": "en",
  "datePublished": "0001-01-01T00:00:00Z",
  "dateModified": "2023-12-07T17:13:05-05:00",
  "author":[{
    "@type": "Person",
    "name": "Yilun Guan"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://guanyilun.github.io/posts/advent_of_code/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Yilun Guan",
    "logo": {
      "@type": "ImageObject",
      "url": "https://guanyilun.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://guanyilun.github.io" accesskey="h" title="Yilun Guan (Alt + H)">Yilun Guan</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://guanyilun.github.io/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://guanyilun.github.io/posts/" title="Posts">
                    <span>Posts</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://guanyilun.github.io">Home</a>&nbsp;»&nbsp;<a href="https://guanyilun.github.io/posts/">Posts</a></div>
    <h1 class="post-title">
      Advent of Code
    </h1>
    <div class="post-meta"><span title='2023-12-07 17:13:05 -0500 EST'>December 7, 2023</span>&nbsp;·&nbsp;13 min&nbsp;·&nbsp;Yilun Guan

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#day-1" aria-label="Day 1">Day 1</a></li>
                <li>
                    <a href="#day-2" aria-label="Day 2">Day 2</a></li>
                <li>
                    <a href="#day-3" aria-label="Day 3">Day 3</a></li>
                <li>
                    <a href="#day-4" aria-label="Day 4">Day 4</a></li>
                <li>
                    <a href="#day-5" aria-label="Day 5">Day 5</a></li>
                <li>
                    <a href="#day-6" aria-label="Day 6">Day 6</a></li>
                <li>
                    <a href="#day-7" aria-label="Day 7">Day 7</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="day-1">Day 1<a hidden class="anchor" aria-hidden="true" href="#day-1">#</a></h2>
<p>This question is about finding the first and last &ldquo;digit&rdquo; which could be written as number or word and computing the sum over all input lines. My attempt with <code>julia</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-julia" data-lang="julia"><span style="display:flex;"><span>digits_lookup <span style="color:#f92672">=</span> <span style="color:#66d9ef">Dict</span>(
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;0&#34;</span> <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">0</span>, <span style="color:#e6db74">&#34;1&#34;</span> <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">1</span>, <span style="color:#e6db74">&#34;2&#34;</span> <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">2</span>, <span style="color:#e6db74">&#34;3&#34;</span> <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">3</span>, <span style="color:#e6db74">&#34;4&#34;</span> <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">4</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;5&#34;</span> <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">5</span>, <span style="color:#e6db74">&#34;6&#34;</span> <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">6</span>, <span style="color:#e6db74">&#34;7&#34;</span> <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">7</span>, <span style="color:#e6db74">&#34;8&#34;</span> <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">8</span>, <span style="color:#e6db74">&#34;9&#34;</span> <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">9</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;zero&#34;</span> <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">0</span>, <span style="color:#e6db74">&#34;one&#34;</span> <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">1</span>, <span style="color:#e6db74">&#34;two&#34;</span> <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">2</span>, <span style="color:#e6db74">&#34;three&#34;</span> <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">3</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;four&#34;</span> <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">4</span>, <span style="color:#e6db74">&#34;five&#34;</span> <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">5</span>, <span style="color:#e6db74">&#34;six&#34;</span> <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">6</span>, <span style="color:#e6db74">&#34;seven&#34;</span> <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">7</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;eight&#34;</span> <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">8</span>, <span style="color:#e6db74">&#34;nine&#34;</span> <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">9</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> parse_number(line)
</span></span><span style="display:flex;"><span>    out, digit <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#66d9ef">in</span> eachindex(line)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (k, v) <span style="color:#66d9ef">in</span> digits_lookup
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> line[i<span style="color:#f92672">:</span>min(i<span style="color:#f92672">+</span>length(k)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, length(line))] <span style="color:#f92672">==</span> k
</span></span><span style="display:flex;"><span>                digit <span style="color:#f92672">=</span> v
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>        out <span style="color:#f92672">=</span> out <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">?</span> out <span style="color:#f92672">:</span> digit <span style="color:#f92672">*</span> <span style="color:#ae81ff">10</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>    out <span style="color:#f92672">+</span> digit
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>lines <span style="color:#f92672">=</span> readlines(<span style="color:#e6db74">&#34;input.txt&#34;</span>)
</span></span><span style="display:flex;"><span>parse_number<span style="color:#f92672">.</span>(lines) <span style="color:#f92672">|&gt;</span> sum
</span></span></code></pre></div><h2 id="day-2">Day 2<a hidden class="anchor" aria-hidden="true" href="#day-2">#</a></h2>
<p>This question practices string splitting. I made use of a trick that
each occurance of &ldquo;red&rdquo;, &ldquo;blue&rdquo;, and &ldquo;green&rdquo; in a line corresponds to
a different draw, so one can easily use one regular expression to find
all matches and then find the upper limit to the number of balls.</p>
<p><strong>Part 1</strong>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-julia" data-lang="julia"><span style="display:flex;"><span>lines <span style="color:#f92672">=</span> readlines(<span style="color:#e6db74">&#34;input.txt&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> process_line(line)
</span></span><span style="display:flex;"><span>    r, g, b <span style="color:#f92672">=</span> map(color <span style="color:#f92672">-&gt;</span> max(map(m <span style="color:#f92672">-&gt;</span> parse(<span style="color:#66d9ef">Int</span>, m<span style="color:#f92672">.</span>captures[<span style="color:#ae81ff">1</span>]), eachmatch(<span style="color:#66d9ef">Regex</span>(<span style="color:#e6db74">&#34;(</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">d+) </span><span style="color:#e6db74">$</span>(color)<span style="color:#e6db74">&#34;</span>), line))<span style="color:#f92672">...</span>),
</span></span><span style="display:flex;"><span>                  [<span style="color:#e6db74">&#34;red&#34;</span>, <span style="color:#e6db74">&#34;green&#34;</span>, <span style="color:#e6db74">&#34;blue&#34;</span>])
</span></span><span style="display:flex;"><span>    (r <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">12</span> <span style="color:#f92672">&amp;&amp;</span> g <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">13</span> <span style="color:#f92672">&amp;&amp;</span> b <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">14</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>map(line <span style="color:#f92672">-&gt;</span> process_line(line[<span style="color:#ae81ff">2</span>]) <span style="color:#f92672">?</span> line[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">:</span> <span style="color:#ae81ff">0</span>, enumerate(lines)) <span style="color:#f92672">|&gt;</span> sum
</span></span></code></pre></div><p><strong>Part 2</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-julia" data-lang="julia"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> process_line(line)
</span></span><span style="display:flex;"><span>    r, g, b <span style="color:#f92672">=</span> map(color <span style="color:#f92672">-&gt;</span> max(map(m <span style="color:#f92672">-&gt;</span> parse(<span style="color:#66d9ef">Int</span>, m<span style="color:#f92672">.</span>captures[<span style="color:#ae81ff">1</span>]), eachmatch(<span style="color:#66d9ef">Regex</span>(<span style="color:#e6db74">&#34;(</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">d+) </span><span style="color:#e6db74">$</span>(color)<span style="color:#e6db74">&#34;</span>), line))<span style="color:#f92672">...</span>),
</span></span><span style="display:flex;"><span>                  [<span style="color:#e6db74">&#34;red&#34;</span>, <span style="color:#e6db74">&#34;green&#34;</span>, <span style="color:#e6db74">&#34;blue&#34;</span>])
</span></span><span style="display:flex;"><span>    r <span style="color:#f92672">*</span> g <span style="color:#f92672">*</span> b
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>map(process_line, lines) <span style="color:#f92672">|&gt;</span> sum
</span></span></code></pre></div><h2 id="day-3">Day 3<a hidden class="anchor" aria-hidden="true" href="#day-3">#</a></h2>
<p>Day 3 problem is about finding numbers that are next to special
characters including diagonally, with an input like</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>467..114..
</span></span><span style="display:flex;"><span>...*......
</span></span><span style="display:flex;"><span>..35..633.
</span></span><span style="display:flex;"><span>......#...
</span></span><span style="display:flex;"><span>617*......
</span></span><span style="display:flex;"><span>.....+.58.
</span></span><span style="display:flex;"><span>..592.....
</span></span><span style="display:flex;"><span>......755.
</span></span><span style="display:flex;"><span>...$.*....
</span></span><span style="display:flex;"><span>.664.598..
</span></span></code></pre></div><p>The adjacent criteria can be described with</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-julia" data-lang="julia"><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">x = (line_num, [indices...])
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">y = (line_num, index)
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> close_by(x, y)
</span></span><span style="display:flex;"><span>    (lx, idx), (ly, idy) <span style="color:#f92672">=</span> x, y
</span></span><span style="display:flex;"><span>    (abs(lx <span style="color:#f92672">-</span> ly) <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">&amp;&amp;</span> <span style="color:#66d9ef">return</span> false
</span></span><span style="display:flex;"><span>    ((idy <span style="color:#f92672">&gt;</span> maximum(idx) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">||</span> (idy <span style="color:#f92672">&lt;</span> minimum(idx) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)) <span style="color:#f92672">&amp;&amp;</span> <span style="color:#66d9ef">return</span> false
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> true
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span></code></pre></div><p>where <code>x</code> is a tuple that contains the line number and the string
indices of each number, and <code>y</code> is a tuple that similarly contains the
line number and an index of the special character (always has length
1).</p>
<p>Next we can parse the numbers and special characters in the format
expected by this function with</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-julia" data-lang="julia"><span style="display:flex;"><span>spc <span style="color:#f92672">=</span> []; num <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>map(x <span style="color:#f92672">-&gt;</span> map(m<span style="color:#f92672">-&gt;</span>push!(spc, (x[<span style="color:#ae81ff">1</span>], m[<span style="color:#ae81ff">1</span>])), findall(<span style="color:#e6db74">r</span><span style="color:#e6db74">&#34;[^0-9</span><span style="color:#960050;background-color:#1e0010">\</span><span style="color:#e6db74">.]&#34;</span>, x[<span style="color:#ae81ff">2</span>])), enumerate(lines))
</span></span><span style="display:flex;"><span>map(x <span style="color:#f92672">-&gt;</span> map(m<span style="color:#f92672">-&gt;</span>push!(num, (x[<span style="color:#ae81ff">1</span>], collect(m))), findall(<span style="color:#e6db74">r</span><span style="color:#e6db74">&#34;(</span><span style="color:#960050;background-color:#1e0010">\</span><span style="color:#e6db74">d+)&#34;</span>, x[<span style="color:#ae81ff">2</span>])), enumerate(lines))
</span></span></code></pre></div><p>where we have used the regex exclusion syntax <code>[^0-9.]</code> to exclude all
dots and numbers to help us find special characters, and have used
matched group notation <code>(\d+)</code> to find all numbers in a line.</p>
<p>The question asks us for the sum of all numbers that are adjacent to a
special character, it can be simply calculated with</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-julia" data-lang="julia"><span style="display:flex;"><span>sum(num <span style="color:#f92672">|&gt;</span> filter(x <span style="color:#f92672">-&gt;</span> any(map(y <span style="color:#f92672">-&gt;</span> close_by(x, y), spc))) <span style="color:#f92672">.|&gt;</span> x <span style="color:#f92672">-&gt;</span> parse(<span style="color:#66d9ef">Int</span>, lines[x[<span style="color:#ae81ff">1</span>]][x[<span style="color:#ae81ff">2</span>]]))
</span></span></code></pre></div><p>For part 2, it defines a concept of &ldquo;gear&rdquo; which is a &ldquo;*&rdquo; character
that has exactly two numbers adjacent to it. And, the question asks us
to find all gears in an input text and compute the product of two
numbers for each gear, and then sum the result for all gears. This can
be easily achieved with</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-julia" data-lang="julia"><span style="display:flex;"><span>prod <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> c <span style="color:#66d9ef">in</span> spc
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> lines[c[<span style="color:#ae81ff">1</span>]][c[<span style="color:#ae81ff">2</span>]] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;*&#39;</span>
</span></span><span style="display:flex;"><span>        nums_close <span style="color:#f92672">=</span> num <span style="color:#f92672">|&gt;</span> filter(n<span style="color:#f92672">-&gt;</span>close_by(n, c))
</span></span><span style="display:flex;"><span>        (length(nums_close) <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span>) <span style="color:#f92672">&amp;&amp;</span> (prod <span style="color:#f92672">+=</span> mapreduce(n<span style="color:#f92672">-&gt;</span>parse(<span style="color:#66d9ef">Int</span>, lines[n[<span style="color:#ae81ff">1</span>]][n[<span style="color:#ae81ff">2</span>]]), <span style="color:#f92672">*</span>, nums_close))
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>prod
</span></span></code></pre></div><p><strong>or</strong>, for people who like one-liner,</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-julia" data-lang="julia"><span style="display:flex;"><span>((spc <span style="color:#f92672">|&gt;</span> filter(x <span style="color:#f92672">-&gt;</span> lines[x[<span style="color:#ae81ff">1</span>]][x[<span style="color:#ae81ff">2</span>]] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;*&#39;</span>)) <span style="color:#f92672">.|&gt;</span> c <span style="color:#f92672">-&gt;</span> ((num <span style="color:#f92672">|&gt;</span> filter(n<span style="color:#f92672">-&gt;</span>close_by(n, c))) <span style="color:#f92672">|&gt;</span> length) <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">?</span> mapreduce(n<span style="color:#f92672">-&gt;</span>parse(<span style="color:#66d9ef">Int</span>, lines[n[<span style="color:#ae81ff">1</span>]][n[<span style="color:#ae81ff">2</span>]]), <span style="color:#f92672">*</span>, num <span style="color:#f92672">|&gt;</span> filter(n<span style="color:#f92672">-&gt;</span>close_by(n, c))) <span style="color:#f92672">:</span> <span style="color:#ae81ff">0</span>) <span style="color:#f92672">|&gt;</span> sum
</span></span></code></pre></div><h2 id="day-4">Day 4<a hidden class="anchor" aria-hidden="true" href="#day-4">#</a></h2>
<p>Today&rsquo;s question is about finding matching numbers on the card,</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>Card 1: 41 48 83 86 17 | 83 86  6 31 17  9 48 53
</span></span><span style="display:flex;"><span>Card 2: 13 32 20 16 61 | 61 30 68 82 17 32 24 19
</span></span><span style="display:flex;"><span>Card 3:  1 21 53 59 44 | 69 82 63 72 16 21 14  1
</span></span><span style="display:flex;"><span>Card 4: 41 92 73 84 69 | 59 84 76 51 58  5 54 83
</span></span><span style="display:flex;"><span>Card 5: 87 83 26 28 32 | 88 30 70 12 93 22 82 36
</span></span><span style="display:flex;"><span>Card 6: 31 18 13 56 72 | 74 77 10 23 35 67 36 11
</span></span></code></pre></div><p>For example, in the first card, there are four matching numbers.</p>
<p>The first part of the question asks us to compute the score of the
card which is calculated as the following: first matching number on a
card gives a score of 1, any additional matches doubles the existing
score. The question requires us to calculate the total score given an
input list of cards.</p>
<p>One simple way to find common numbers amount list is through <code>Set</code> interaction:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-julia" data-lang="julia"><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">expr: string with numbers separated by spaces
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> parse_int(expr)
</span></span><span style="display:flex;"><span>    strip(expr) <span style="color:#f92672">|&gt;</span> x <span style="color:#f92672">-&gt;</span> split(x, <span style="color:#e6db74">r</span><span style="color:#e6db74">&#34;</span><span style="color:#960050;background-color:#1e0010">\</span><span style="color:#e6db74">s+&#34;</span>) <span style="color:#f92672">.|&gt;</span> x <span style="color:#f92672">-&gt;</span> parse(<span style="color:#66d9ef">Int</span>, x)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">count the number of winning numbers
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> get_match_count(line)
</span></span><span style="display:flex;"><span>    (split(line, <span style="color:#e6db74">&#34;:&#34;</span>)[<span style="color:#ae81ff">2</span>] <span style="color:#f92672">|&gt;</span> x <span style="color:#f92672">-&gt;</span> split(x, <span style="color:#e6db74">&#34;|&#34;</span>) <span style="color:#f92672">.|&gt;</span> parse_int <span style="color:#f92672">.|&gt;</span> <span style="color:#66d9ef">Set</span>) <span style="color:#f92672">|&gt;</span> x <span style="color:#f92672">-&gt;</span> intersect(x<span style="color:#f92672">...</span>) <span style="color:#f92672">|&gt;</span> length
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># get total score</span>
</span></span><span style="display:flex;"><span>(get_match_count<span style="color:#f92672">.</span>(lines) <span style="color:#f92672">.|&gt;</span> x <span style="color:#f92672">-&gt;</span> x <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">?</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">:</span> <span style="color:#ae81ff">2</span><span style="color:#f92672">^</span>(x<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)) <span style="color:#f92672">|&gt;</span> sum
</span></span></code></pre></div><p>where we defined the <code>get_match_count</code> function to find the total
number of winning numbers based on the number of elements in the
intersection between the two lists. We then use the numbers for each
card to calculate the total score based on the description, which is
\(2^{x-1}\) except when \(x\) is 0 which has a zero score.</p>
<p>For part two, instead of calculating scores, each card rewards
subsequent n cards with n the number of matching numbers in the card.
For example, card 1 has 4 matching numbers and will give card 2, 3, 4,
5 as reward, so now there are two copies of card 2 for example. When
resolving card 2 award, we repeat the process except we have two
copies of card 2 now. It accumulates throughout the card stack, and
the question asks us to find the total number of cards at the end of
resolving all cards. Here is my solution:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-julia" data-lang="julia"><span style="display:flex;"><span>multiplier <span style="color:#f92672">=</span> [ones(length(lines)); zeros(<span style="color:#ae81ff">10</span>)]
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (i, line) <span style="color:#66d9ef">in</span> enumerate(lines)
</span></span><span style="display:flex;"><span>    n_match <span style="color:#f92672">=</span> get_match_count(line)
</span></span><span style="display:flex;"><span>    multiplier[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span><span style="color:#f92672">:</span>i<span style="color:#f92672">+</span>n_match] <span style="color:#f92672">.+=</span> multiplier[i]
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>sum(multiplier)
</span></span></code></pre></div><p>where I used the <code>multiplier</code> to keep track of the number of card
copies. The 10 additional zeros I padded to the multiplier
is to ensure the <code>multiplier[i+i:n_match]</code> never goes out of range.</p>
<h2 id="day-5">Day 5<a hidden class="anchor" aria-hidden="true" href="#day-5">#</a></h2>
<p>Today&rsquo;s question tests table mapping. It defines some mapping rules from various quantities such as
mapping between seed and soil, mapping between soil to fertilizer, and so on, eventually to location.
The rule is given like this</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>seeds: 79 14 55 13
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>seed-to-soil map:
</span></span><span style="display:flex;"><span>50 98 2
</span></span><span style="display:flex;"><span>52 50 48
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>soil-to-fertilizer map:
</span></span><span style="display:flex;"><span>0 15 37
</span></span><span style="display:flex;"><span>37 52 2
</span></span><span style="display:flex;"><span>39 0 15
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>fertilizer-to-water map:
</span></span><span style="display:flex;"><span>49 53 8
</span></span><span style="display:flex;"><span>0 11 42
</span></span><span style="display:flex;"><span>42 0 7
</span></span><span style="display:flex;"><span>57 7 4
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>water-to-light map:
</span></span><span style="display:flex;"><span>88 18 7
</span></span><span style="display:flex;"><span>18 25 70
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>light-to-temperature map:
</span></span><span style="display:flex;"><span>45 77 23
</span></span><span style="display:flex;"><span>81 45 19
</span></span><span style="display:flex;"><span>68 64 13
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>temperature-to-humidity map:
</span></span><span style="display:flex;"><span>0 69 1
</span></span><span style="display:flex;"><span>1 0 69
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>humidity-to-location map:
</span></span><span style="display:flex;"><span>60 56 37
</span></span><span style="display:flex;"><span>56 93 4
</span></span></code></pre></div><p>For part one, the question asked us to traverse the series of mapping
to find the correct location for each input seed and identifies the
nearest location which corresponds to then smallest location id.</p>
<p>First we need to work on parsing the input text:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-julia" data-lang="julia"><span style="display:flex;"><span>seeds <span style="color:#f92672">=</span> match(<span style="color:#e6db74">r</span><span style="color:#e6db74">&#34;seeds: (.*)</span><span style="color:#960050;background-color:#1e0010">\</span><span style="color:#e6db74">n&#34;</span>, text)<span style="color:#f92672">.</span>captures[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">|&gt;</span> split <span style="color:#f92672">.|&gt;</span> x <span style="color:#f92672">-&gt;</span> parse(<span style="color:#66d9ef">Int</span>, x)
</span></span><span style="display:flex;"><span>parse_arr <span style="color:#f92672">=</span> cat <span style="color:#f92672">-&gt;</span> match(<span style="color:#66d9ef">Regex</span>(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">$</span>(cat)<span style="color:#e6db74"> map:</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">s*</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">n((?:</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">s*</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">d+</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">s+</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">d+</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">s+</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">d+</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">s*</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">n)+)&#34;</span>), text)<span style="color:#f92672">.</span>captures[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">|&gt;</span> split <span style="color:#f92672">|&gt;</span> x <span style="color:#f92672">-&gt;</span> reshape(x, <span style="color:#ae81ff">3</span>, <span style="color:#f92672">:</span>) <span style="color:#f92672">.|&gt;</span> x <span style="color:#f92672">-&gt;</span> parse<span style="color:#f92672">.</span>(<span style="color:#66d9ef">Int</span>, x)
</span></span><span style="display:flex;"><span>parse_map <span style="color:#f92672">=</span> cat <span style="color:#f92672">-&gt;</span> parse_arr(cat) <span style="color:#f92672">|&gt;</span> x <span style="color:#f92672">-&gt;</span> map(eachcol(x)) <span style="color:#66d9ef">do</span> m
</span></span><span style="display:flex;"><span>    ((m[<span style="color:#ae81ff">2</span>], m[<span style="color:#ae81ff">2</span>]<span style="color:#f92672">+</span>m[<span style="color:#ae81ff">3</span>]<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>), (m[<span style="color:#ae81ff">1</span>], m[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">+</span>m[<span style="color:#ae81ff">3</span>]<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>))
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>mappings <span style="color:#f92672">=</span> parse_map<span style="color:#f92672">.</span>([
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;seed-to-soil&#34;</span>, <span style="color:#e6db74">&#34;soil-to-fertilizer&#34;</span>, <span style="color:#e6db74">&#34;fertilizer-to-water&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;water-to-light&#34;</span>, <span style="color:#e6db74">&#34;light-to-temperature&#34;</span>, <span style="color:#e6db74">&#34;temperature-to-humidity&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;humidity-to-location&#34;</span>
</span></span><span style="display:flex;"><span>])
</span></span></code></pre></div><p>In the input file, the mapping rule is specified as <code>(dest_start, src_start, range)</code>;
I have converted it to a more readable format: <code>((src_start, src_stop), (dest_start, dest_stop))</code>
with the <code>parse_map</code> function. The game rule also specifies that any numbers not covered in the
specified ranges will passthrough to itself. For completeness, I will also add these dummy ranges:
<code>((0, first), (0, first))</code> and <code>((last, inf), (last, inf))</code>. I used <code>inf</code> because I don&rsquo;t know the
largest number in the input text and I don&rsquo;t want to compute it unnecessarily:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-julia" data-lang="julia"><span style="display:flex;"><span>mappings <span style="color:#f92672">=</span> map(mappings) <span style="color:#66d9ef">do</span> mapping
</span></span><span style="display:flex;"><span>    strt <span style="color:#f92672">=</span> (<span style="color:#ae81ff">0</span>, minimum(mapping[i][<span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">1</span>] <span style="color:#66d9ef">for</span> i <span style="color:#66d9ef">in</span> eachindex(mapping)))
</span></span><span style="display:flex;"><span>    stop <span style="color:#f92672">=</span> (maximum(mapping[i][<span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">2</span>] <span style="color:#66d9ef">for</span> i <span style="color:#66d9ef">in</span> eachindex(mapping)), Inf)
</span></span><span style="display:flex;"><span>    strt[<span style="color:#ae81ff">2</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">?</span> (mapping<span style="color:#f92672">...</span>, (stop, stop)) <span style="color:#f92672">:</span> ((strt, strt), mapping<span style="color:#f92672">...</span>, (stop, stop))
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span></code></pre></div><p>To apply a mapping, we simply go through the source ranges to find a
match and apply the right offset to the destination range.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-julia" data-lang="julia"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> apply_mapping(i, mapping)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> m <span style="color:#66d9ef">in</span> mapping
</span></span><span style="display:flex;"><span>        (m[<span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">1</span>] <span style="color:#f92672">&lt;=</span> i <span style="color:#f92672">&lt;=</span> m[<span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">2</span>]) <span style="color:#f92672">&amp;&amp;</span> <span style="color:#66d9ef">return</span> m[<span style="color:#ae81ff">2</span>][<span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> (i <span style="color:#f92672">-</span> m[<span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">1</span>])
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> i
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span></code></pre></div><p>Then we can find the &ldquo;location&rdquo; for each &ldquo;seed&rdquo; by traversing all mappings via</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-julia" data-lang="julia"><span style="display:flex;"><span>foldl((x, f) <span style="color:#f92672">-&gt;</span> f<span style="color:#f92672">.</span>(x), [x <span style="color:#f92672">-&gt;</span> apply_mapping(x, m) <span style="color:#66d9ef">for</span> m <span style="color:#66d9ef">in</span> mappings], init<span style="color:#f92672">=</span>seeds) <span style="color:#f92672">|&gt;</span> minimum
</span></span></code></pre></div><p>and get the minimum location. This solves the first part.</p>
<p>In part 2 of the question, it suggests the input seeds, instead of
being individual seeds, are actually pairs of numbers, with the second
number specifying a range. The method that we setup in part 1 then
becomes very costly because it may require us to repeatedly
calculating mapping over up to 1e9 points (as in the input). It&rsquo;s not
prohibitive for a modern computer but unnecessary, because we could
simply keep track of how intervals map to each other, i.e., how
different intervals in &ldquo;seeds&rdquo; space map onto &ldquo;locations&rdquo; space.
To work out the interval mapping, we first setup some useful functions
that deals with intersections of intervals</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-julia" data-lang="julia"><span style="display:flex;"><span>has_intersect <span style="color:#f92672">=</span> (inter1, inter2) <span style="color:#f92672">-&gt;</span> sign(inter1[<span style="color:#ae81ff">2</span>] <span style="color:#f92672">-</span> inter2[<span style="color:#ae81ff">1</span>]) <span style="color:#f92672">*</span> sign(inter1[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">-</span> inter2[<span style="color:#ae81ff">2</span>]) <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>interval_intersect <span style="color:#f92672">=</span> (inter1, inter2) <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">begin</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">!</span>has_intersect(inter1, inter2) <span style="color:#f92672">&amp;&amp;</span> <span style="color:#66d9ef">return</span> nothing
</span></span><span style="display:flex;"><span>    (max(inter1[<span style="color:#ae81ff">1</span>], inter2[<span style="color:#ae81ff">1</span>]), min(inter1[<span style="color:#ae81ff">2</span>], inter2[<span style="color:#ae81ff">2</span>]))
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span></code></pre></div><p>To map intervals in input space of <code>map1</code> to output space of <code>map2</code>, we can use this function</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-julia" data-lang="julia"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> reduce_mapping(map1, map2)
</span></span><span style="display:flex;"><span>    omap <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> m1 <span style="color:#66d9ef">in</span> map1
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> m2 <span style="color:#66d9ef">in</span> map2
</span></span><span style="display:flex;"><span>            inter <span style="color:#f92672">=</span> interval_intersect(m1[<span style="color:#ae81ff">2</span>], m2[<span style="color:#ae81ff">1</span>])
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">!</span>isnothing(inter)
</span></span><span style="display:flex;"><span>                offset1 <span style="color:#f92672">=</span>  m1[<span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">1</span>] <span style="color:#f92672">-</span> m1[<span style="color:#ae81ff">2</span>][<span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>                offset2 <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>m2[<span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> m2[<span style="color:#ae81ff">2</span>][<span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>                push!(omap, (inter <span style="color:#f92672">.+</span> offset1, inter <span style="color:#f92672">.+</span> offset2))
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>    omap
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span></code></pre></div><p>For example, given</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>map1 = (((0, 50), (0, 50)), ((98, 99), (50, 51)), ((50, 97), (52, 99)), ((99, Inf), (99, Inf)))
</span></span><span style="display:flex;"><span>map2 = (((15, 51), (0, 36)), ((52, 53), (37, 38)), ((0, 14), (39, 53)), ((53, Inf), (53, Inf)))
</span></span></code></pre></div><p>the reduced mapping is</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>reduce_mapping(map1, map2) = (((15, 50), (0, 35)), ((0, 14), (39, 53)), ((98, 99), (35, 36)), ((50, 51), (37, 38)), ((51, 97.0), (53, 99.0)), ((99, Inf), (99, Inf)))
</span></span></code></pre></div><p>We can then apply this reduction through all mappings to work out
interval mappings between seed space and location space, by</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-julia" data-lang="julia"><span style="display:flex;"><span>omap <span style="color:#f92672">=</span> foldl((x, y) <span style="color:#f92672">-&gt;</span> reduce_mapping(x, y), mappings)
</span></span></code></pre></div><p>To find out the nearest location again like in part one, we can find
intersections of the input ranges to the intervals specified in the
mapping and figure out how these intervals mapped to location space to
identify the nearest location. The math is identical to how we compute
the combined mapping in <code>reduce_mapping</code>, so we can reuse it with</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-julia" data-lang="julia"><span style="display:flex;"><span><span style="color:#75715e"># now seeds are pairs of numbers which we will convert to a mapping format</span>
</span></span><span style="display:flex;"><span>imap <span style="color:#f92672">=</span> seeds <span style="color:#f92672">|&gt;</span> x <span style="color:#f92672">-&gt;</span> reshape(x, <span style="color:#ae81ff">2</span>, <span style="color:#f92672">:</span>) <span style="color:#f92672">|&gt;</span> x <span style="color:#f92672">-&gt;</span> map(eachcol(x)) <span style="color:#66d9ef">do</span> c
</span></span><span style="display:flex;"><span>    ((c[<span style="color:#ae81ff">1</span>], c[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> c[<span style="color:#ae81ff">2</span>] <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>), (c[<span style="color:#ae81ff">1</span>], c[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> c[<span style="color:#ae81ff">2</span>] <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>))
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>reduce_mapping(imap, omap) <span style="color:#f92672">|&gt;</span> m <span style="color:#f92672">-&gt;</span> map(x <span style="color:#f92672">-&gt;</span> x[<span style="color:#ae81ff">2</span>][<span style="color:#ae81ff">1</span>], m) <span style="color:#f92672">|&gt;</span> minimum
</span></span></code></pre></div><p>This allows me to easily find the minimum location.</p>
<h2 id="day-6">Day 6<a hidden class="anchor" aria-hidden="true" href="#day-6">#</a></h2>
<p>Today&rsquo;s question very straightforward, about finding number of integers
of a quadratic function above a given threshold, so I will just record my
solution here:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-julia" data-lang="julia"><span style="display:flex;"><span><span style="color:#75715e"># parse data</span>
</span></span><span style="display:flex;"><span>data <span style="color:#f92672">=</span> map(l <span style="color:#f92672">-&gt;</span> split(l, <span style="color:#e6db74">r</span><span style="color:#e6db74">&#34;</span><span style="color:#960050;background-color:#1e0010">\</span><span style="color:#e6db74">s+&#34;</span>)[<span style="color:#ae81ff">2</span><span style="color:#f92672">:</span><span style="color:#66d9ef">end</span>] <span style="color:#f92672">.|&gt;</span> x <span style="color:#f92672">-&gt;</span> parse(<span style="color:#66d9ef">Int</span>, x), readlines(<span style="color:#e6db74">&#34;input.txt&#34;</span>)) <span style="color:#f92672">|&gt;</span> stack  <span style="color:#75715e"># part 1</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># data = map(l -&gt; (split(l, r&#34;\s+&#34;)[2:end] |&gt; join) |&gt; x -&gt; parse(Int, x), readlines(&#34;input.txt&#34;)) |&gt; stack  # for part 2</span>
</span></span><span style="display:flex;"><span>map(eachrow(data)) <span style="color:#66d9ef">do</span> r
</span></span><span style="display:flex;"><span>    t, d <span style="color:#f92672">=</span> r
</span></span><span style="display:flex;"><span>    ceil((t<span style="color:#f92672">+</span>sqrt(t<span style="color:#f92672">^</span><span style="color:#ae81ff">2</span><span style="color:#f92672">-</span><span style="color:#ae81ff">4</span>d))<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>) <span style="color:#f92672">-</span> floor((t<span style="color:#f92672">-</span>sqrt(t<span style="color:#f92672">^</span><span style="color:#ae81ff">2</span><span style="color:#f92672">-</span><span style="color:#ae81ff">4</span>d))<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span> <span style="color:#f92672">|&gt;</span> prod
</span></span></code></pre></div><p>I did learn a good trick from this exercise, when counting numbers of
integers between <code>lower</code> and <code>upper</code>, using
<code>floor(upper) - ceil(lower) + 1</code> is prune to error because
it will fail when <code>lower</code> or <code>upper</code> are on integers so I had to
add a conditional for this. A robust way to count is to use
<code>ceil(upper) - floor(lower) - 1</code>, which I just learned from reddit.</p>
<h2 id="day-7">Day 7<a hidden class="anchor" aria-hidden="true" href="#day-7">#</a></h2>
<p>Today&rsquo;s question is about ranking sets of cards. There are thirteen cards with
ranking (descending): A, K, Q, J, T, 9, 8, 7, 6, 5, 4, 3, 2. Each hand has 5
cards, with some combination types ranking (descending):</p>
<ul>
<li>Five of a kind, where all five cards have the same label: AAAAA</li>
<li>Four of a kind, where four cards have the same label and one card has a different label: AA8AA</li>
<li>Full house, where three cards have the same label, and the remaining two cards share a different label: 23332</li>
<li>Three of a kind, where three cards have the same label, and the remaining two cards are each different from any other card in the hand: TTT98</li>
<li>Two pair, where two cards share one label, two other cards share a second label, and the remaining card has a third label: 23432</li>
<li>One pair, where two cards share one label, and the other three cards have a different label from the pair and each other: A23A4</li>
<li>High card, where all cards&rsquo; labels are distinct: 23456</li>
</ul>
<p>When two hands has the same type, it compares individual cards in the
order they appear by the card order. The first part asks us to find ranking of cards and compute the total <code>ranking * bidding</code>.
Today&rsquo;s program will be in python. First parsing the file with</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">from</span> pathlib <span style="color:#f92672">import</span> Path
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>lines <span style="color:#f92672">=</span> Path(<span style="color:#e6db74">&#34;input.txt&#34;</span>)<span style="color:#f92672">.</span>read_text()<span style="color:#f92672">.</span>splitlines()
</span></span></code></pre></div><p>Suppose I have a hand of cards: <code>AKAA2</code>, how do I rank its type? The original method I came up with is to define some patterns
based on the number of repeated cards and then find the ranking as its index in the list:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">from</span> collections <span style="color:#f92672">import</span> Counter
</span></span><span style="display:flex;"><span>hand <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;AKAA2&#34;</span>  <span style="color:#75715e"># an example</span>
</span></span><span style="display:flex;"><span>patterns <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#34;11111&#34;</span>, <span style="color:#e6db74">&#34;1112&#34;</span>, <span style="color:#e6db74">&#34;122&#34;</span>, <span style="color:#e6db74">&#34;113&#34;</span>, <span style="color:#e6db74">&#34;23&#34;</span>, <span style="color:#e6db74">&#34;14&#34;</span>, <span style="color:#e6db74">&#34;5&#34;</span>]
</span></span><span style="display:flex;"><span>card_type <span style="color:#f92672">=</span> patterns<span style="color:#f92672">.</span>index(<span style="color:#e6db74">&#34;&#34;</span><span style="color:#f92672">.</span>join(map(str, sorted(Counter(hand)<span style="color:#f92672">.</span>values()))))
</span></span></code></pre></div><p>I read about a neat ranking trick from some reddit users, which I thought will be nice to record here:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>card_type <span style="color:#f92672">=</span> max(map(hand<span style="color:#f92672">.</span>count, hand)) <span style="color:#f92672">-</span> len(set(hand))
</span></span></code></pre></div><p>one could check that they have the same ranking effect by comparing the ranking numbers</p>
<table>
<thead>
<tr>
<th>pattern</th>
<th>method 1</th>
<th>method 2</th>
</tr>
</thead>
<tbody>
<tr>
<td>11111</td>
<td>0</td>
<td>-4</td>
</tr>
<tr>
<td>1112</td>
<td>1</td>
<td>-2</td>
</tr>
<tr>
<td>122</td>
<td>2</td>
<td>-1</td>
</tr>
<tr>
<td>113</td>
<td>3</td>
<td>0</td>
</tr>
<tr>
<td>23</td>
<td>4</td>
<td>1</td>
</tr>
<tr>
<td>14</td>
<td>5</td>
<td>2</td>
</tr>
<tr>
<td>5</td>
<td>6</td>
<td>4</td>
</tr>
</tbody>
</table>
<p>To compare hands of the same type, we can make use of the build-in
comparison in python that compares list (or tuple) in order, which is
exactly what we need (I also learned about it today). For example,
this works in Python:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>[<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">2</span>]) <span style="color:#f92672">&gt;</span> [<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># so are these</span>
</span></span><span style="display:flex;"><span>(<span style="color:#ae81ff">3</span>, [<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">2</span>]) <span style="color:#f92672">&gt;</span> (<span style="color:#ae81ff">3</span>, [<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">1</span>])
</span></span><span style="display:flex;"><span>(<span style="color:#ae81ff">3</span>, [<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">1</span>]) <span style="color:#f92672">&gt;</span> (<span style="color:#ae81ff">2</span>, [<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">2</span>])
</span></span></code></pre></div><p>Therefore we can rank hands simply with</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>orders <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;23456789TJQKA&#34;</span>
</span></span><span style="display:flex;"><span>rankings <span style="color:#f92672">=</span> sorted((max(map(hand<span style="color:#f92672">.</span>count, hand)) <span style="color:#f92672">-</span> len(set(hand)),
</span></span><span style="display:flex;"><span>                   list(map(orders<span style="color:#f92672">.</span>index, hand)), int(bid)) <span style="color:#66d9ef">for</span> line <span style="color:#f92672">in</span> lines <span style="color:#66d9ef">if</span>
</span></span><span style="display:flex;"><span>                  (hand <span style="color:#f92672">:=</span> line<span style="color:#f92672">.</span>split()[<span style="color:#ae81ff">0</span>]) <span style="color:#f92672">and</span> (bid <span style="color:#f92672">:=</span> line<span style="color:#f92672">.</span>split()[<span style="color:#ae81ff">1</span>]))
</span></span></code></pre></div><p>then one can easily get ranking * bid as question asks</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>sum((i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>) <span style="color:#f92672">*</span> bid <span style="color:#66d9ef">for</span> i, (_, _, bid) <span style="color:#f92672">in</span> enumerate(rankings))
</span></span></code></pre></div><p>For part 2, the question introduces some special rule for Joker card
that it could be used to represent any card to maximize the hand
ranking when considering hand types. One could easily see that to
maximize hand ranking, we would always want to replace Joker cards
with the most frequently appearing card. To compensate for the
increased power of Joker, its individual card ranking has becomes the
smallest. So to solve part 2, we simply need to rerun part 1 with a
minor correction that</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>hand <span style="color:#f92672">=</span> hand<span style="color:#f92672">.</span>replace(<span style="color:#e6db74">&#34;J&#34;</span>, Counter(<span style="color:#e6db74">&#34;J&#34;</span>)<span style="color:#f92672">.</span>most_common()[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">0</span>])
</span></span><span style="display:flex;"><span>orders <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;J23456789TQKA&#34;</span>
</span></span></code></pre></div><p>so I will not repeat. I liked today&rsquo;s puzzle because it taught me a
few tricks in python such as structured comparisons, and inline
assignments.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="next" href="https://guanyilun.github.io/posts/shower/">
    <span class="title">Next »</span>
    <br>
    <span>Shower Thoughts</span>
  </a>
</nav>


<div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share Advent of Code on twitter"
        href="https://twitter.com/intent/tweet/?text=Advent%20of%20Code&amp;url=https%3a%2f%2fguanyilun.github.io%2fposts%2fadvent_of_code%2f&amp;hashtags=">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-253.927,424.544c135.939,0 210.268,-112.643 210.268,-210.268c0,-3.218 0,-6.437 -0.153,-9.502c14.406,-10.421 26.973,-23.448 36.935,-38.314c-13.18,5.824 -27.433,9.809 -42.452,11.648c15.326,-9.196 26.973,-23.602 32.49,-40.92c-14.252,8.429 -30.038,14.56 -46.896,17.931c-13.487,-14.406 -32.644,-23.295 -53.946,-23.295c-40.767,0 -73.87,33.104 -73.87,73.87c0,5.824 0.613,11.494 1.992,16.858c-61.456,-3.065 -115.862,-32.49 -152.337,-77.241c-6.284,10.881 -9.962,23.601 -9.962,37.088c0,25.594 13.027,48.276 32.95,61.456c-12.107,-0.307 -23.448,-3.678 -33.41,-9.196l0,0.92c0,35.862 25.441,65.594 59.311,72.49c-6.13,1.686 -12.72,2.606 -19.464,2.606c-4.751,0 -9.348,-0.46 -13.946,-1.38c9.349,29.426 36.628,50.728 68.965,51.341c-25.287,19.771 -57.164,31.571 -91.8,31.571c-5.977,0 -11.801,-0.306 -17.625,-1.073c32.337,21.15 71.264,33.41 112.95,33.41Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Advent of Code on linkedin"
        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fguanyilun.github.io%2fposts%2fadvent_of_code%2f&amp;title=Advent%20of%20Code&amp;summary=Advent%20of%20Code&amp;source=https%3a%2f%2fguanyilun.github.io%2fposts%2fadvent_of_code%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Advent of Code on reddit"
        href="https://reddit.com/submit?url=https%3a%2f%2fguanyilun.github.io%2fposts%2fadvent_of_code%2f&title=Advent%20of%20Code">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Advent of Code on facebook"
        href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fguanyilun.github.io%2fposts%2fadvent_of_code%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Advent of Code on whatsapp"
        href="https://api.whatsapp.com/send?text=Advent%20of%20Code%20-%20https%3a%2f%2fguanyilun.github.io%2fposts%2fadvent_of_code%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Advent of Code on telegram"
        href="https://telegram.me/share/url?text=Advent%20of%20Code&amp;url=https%3a%2f%2fguanyilun.github.io%2fposts%2fadvent_of_code%2f">
        <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
            <path
                d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
        </svg>
    </a>
</div>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://guanyilun.github.io">Yilun Guan</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
